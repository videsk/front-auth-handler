{"version":3,"sources":["webpack://WebAuth/webpack/universalModuleDefinition","webpack://WebAuth/webpack/bootstrap","webpack://WebAuth/./index.js","webpack://WebAuth/./node_modules/jwt-decode/build/jwt-decode.esm.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","jwt","require","version","WebAuth","options","keys","accessToken","refreshToken","config","endpoints","hostname","url","method","authorizationType","headers","body","status","expired","ok","attempts","this","events","error","renewed","empty","storage","localStorage","getItem","_expirationAccessToken","_expirationRefreshToken","_stop","access","refresh","remember","constructor","getTokens","getExpirationToken","e","saveTokens","askServer","observer","renew","event","callback","removeItem","sessionStorage","isAccessTokenExpired","Date","getTime","setTimeout","isRefreshTokenExpired","response","tokenName","tokens","xHeaders","assign","Authorization","xBody","fullURL","payload","includes","toLowerCase","JSON","stringify","fetch","json","Error","clean","setItem","JWT","decoded","exp","Infinity","message","atob","String","replace","length","a","charAt","fromCharCode","indexOf","decodeURIComponent","charCodeAt","toString","toUpperCase","header","parse","split","InvalidTokenError"],"mappings":"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","file":"web-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebAuth\"] = factory();\n\telse\n\t\troot[\"WebAuth\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const jwt = require('jwt-decode');\nconst { version } = require('./package.json');\n\nclass WebAuth {\n\n    constructor(options = {}) {\n        const {\n            keys = { accessToken: 'auth-key', refreshToken: 'auth-key-refresh' },\n            config = {\n                endpoints: {\n                    hostname: 'http://localhost:3000/',\n                    accessToken: {\n                        url: 'check-token',\n                        method: 'GET',\n                        authorizationType: 'Bearer',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: {},\n                        keys: {\n                            accessToken: 'accessToken',\n                            refreshToken: 'refreshToken',\n                        },\n                        status: {\n                            expired: 401,\n                            ok: 200,\n                        },\n                        attempts: 3\n                    },\n                    refreshToken: {\n                        url: 'refresh-token',\n                        method: 'POST',\n                        authorizationType: 'Bearer',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: {},\n                        keys: {\n                            accessToken: 'accessToken',\n                            refreshToken: 'refreshToken',\n                        },\n                        status: {\n                            expired: 401,\n                            ok: 201,\n                        },\n                        attempts: 3\n                    },\n                },\n            },\n        } = options;\n\n        this.keys = keys;\n        this.events = {\n            expired: () => {},\n            error: () => {},\n            renewed: () => {},\n            empty: () => {},\n        };\n        this.config = config;\n        this.storage = (window.localStorage.getItem(this.keys.accessToken)) ? 'localStorage' : 'sessionStorage';\n\n        this._expirationAccessToken = null;\n        this._expirationRefreshToken = null;\n        this._stop = false;\n        this.version = version;\n    }\n\n    /**\n     * Set WebAuth and start observer\n     * @param access {String=} - accessToken\n     * @param refresh {String=} - refreshToken\n     * @param remember {Boolean=} - Save in session or local storage\n     * @returns {Promise<*|undefined>}\n     */\n    async set(access = '', refresh = '', remember) {\n        if (typeof remember === 'boolean') this.storage = remember ? 'localStorage' : 'sessionStorage';\n        const { accessToken = access, refreshToken = refresh } = this.constructor.getTokens(this.storage, this.keys);\n        if (!accessToken) return this.events.empty();\n        // Save expiration\n        try {\n            this._expirationAccessToken = this.constructor.getExpirationToken(accessToken);\n            if (refreshToken) this._expirationRefreshToken = this.constructor.getExpirationToken(refreshToken);\n        } catch (e) {\n            return this.events.error(e);\n        }\n        this.constructor.saveTokens(this.storage, this.keys, accessToken, refreshToken);\n\n        try {\n            await this.askServer();\n            return this.observer();\n        } catch (e) {\n            if (e !== 'undefined') return this.events.error(e);\n            this.events.expired('accessToken');\n            return this.renew();\n        }\n    }\n\n    /**\n     * Set event\n     * @param event\n     * @param callback\n     */\n    on(event = '', callback = () => {}) {\n        this.events[event] = callback;\n    }\n\n    /**\n     * Clean tokens from storage\n     */\n    clean() {\n        // Remove from localStorage\n        window.localStorage.removeItem(this.keys.accessToken);\n        window.localStorage.removeItem(this.keys.refreshToken);\n        // Remove from sessionStorage\n        window.sessionStorage.removeItem(this.keys.accessToken);\n        window.sessionStorage.removeItem(this.keys.refreshToken);\n    }\n\n    /**\n     * Start expiration tokens observer\n     * @returns {Promise<*|undefined>|NodeJS.Timeout|*}\n     */\n    observer(attempts = 1) {\n        if (this._stop || !this._expirationAccessToken) return;\n        const isAccessTokenExpired = new Date().getTime() > this._expirationAccessToken;\n        if (!isAccessTokenExpired) return setTimeout(() => this.observer(), 1000);\n        if (attempts < 2) this.events.expired('accessToken');\n        if (!this._expirationRefreshToken) return;\n        // Try to get new refreshToken\n        return this.renew(attempts);\n    }\n\n    /**\n     * Force renew accessToken\n     * @returns {Promise<*|undefined|NodeJS.Timeout>}\n     */\n    async renew(attempts = 1) {\n        // Check refreshToken was not expired\n        const isRefreshTokenExpired = new Date().getTime() > this._expirationRefreshToken;\n        if (isRefreshTokenExpired) return this.events.expired('refreshToken');\n\n        const { refreshToken: config } = this.config.endpoints;\n        const { refreshToken } = this.constructor.getTokens(this.storage, this.keys);\n        try {\n            const { accessToken } = config.keys;\n            const response = await this.askServer('refreshToken');\n            this.constructor.saveTokens(this.storage, this.keys, response[accessToken], refreshToken);\n            this._expirationAccessToken = this.constructor.getExpirationToken(response[accessToken]);\n            this._expirationRefreshToken = this.constructor.getExpirationToken(refreshToken);\n            this.events.renewed();\n            return this.observer();\n        } catch (e) {\n            if (!e) return; // Only if was expired\n            if (attempts >= config.attempts) return this.events.error(e);\n            setTimeout(() => this.observer(attempts + 1), 1000 * (attempts + 1));\n        }\n    }\n\n    /**\n     * Send to server request to check or renew access token\n     * @param tokenName {String} - Could be accessToken or refreshToken\n     * @returns {Promise<any>}\n     */\n    async askServer(tokenName = 'accessToken') {\n        if (this._stop) return;\n        const {url, body, headers, method, authorizationType, keys, status} = this.config.endpoints[tokenName];\n        // Create payload\n        const tokens = this.constructor.getTokens(this.storage, this.keys);\n        const xHeaders = Object.assign(headers, {Authorization: `${authorizationType} ${tokens[tokenName]}`});\n        const xBody = Object.assign(body, { [keys[tokenName]]: tokens[tokenName] });\n        // Send request\n        const fullURL = `${this.config.endpoints.hostname}${url}`;\n        const payload = { method, headers: xHeaders };\n        if (['post', 'patch', 'put'].includes(method.toLowerCase())) payload.body = JSON.stringify(xBody);\n        const response = await fetch(fullURL, payload);\n        if (response.status === status.ok) return response.json();\n        if (response.status !== status.expired && response instanceof Error) throw response;\n        // Clean store and fire expired event\n        this.clean();\n        throw this.events.expired(tokenName);\n    }\n\n    /**\n     * Stop observer and clean tokens\n     * @param value\n     */\n    stop(value = true) {\n        this._stop = value;\n        this.clean();\n    }\n\n    /**\n     * Get tokens from storage\n     * @param storage {String} - Session or local storage\n     * @param keys {Object} - Key names of storage\n     * @returns {{accessToken: *, refreshToken: *}}\n     */\n    static getTokens(storage = 'sessionStorage', keys = {}) {\n        const accessToken = window[storage].getItem(keys.accessToken);\n        const refreshToken = window[storage].getItem(keys.refreshToken);\n        return (accessToken || refreshToken) ? { accessToken, refreshToken } : {};\n    }\n\n    /**\n     * Save tokens in storage\n     * @param storage {String} - Name of storage\n     * @param keys {Object} - Key names of storage\n     * @param accessToken {String} - JWT access\n     * @param refreshToken {String} - JWT refresh\n     */\n    static saveTokens(storage = 'sessionStorage', keys = {}, accessToken = '', refreshToken = '') {\n        window[storage].setItem(keys.accessToken, accessToken);\n        window[storage].setItem(keys.refreshToken, refreshToken);\n    }\n\n    /**\n     * Get expiration of JWT\n     * @param JWT {String} - Valid JWT\n     * @returns {number|number}\n     */\n    static getExpirationToken(JWT = '') {\n        const decoded = jwt(JWT);\n        if (typeof decoded !== 'object') throw new Error('Invalid JWT, please check.');\n        return ('exp' in decoded) ? decoded.exp * 1000 : Infinity;\n    }\n\n    /**\n     * Get the name of storage based on tokens existence\n     * @param key\n     * @returns {string} - Key name want search in storage\n     */\n    static getStorage(key = '') {\n        return (window.localStorage.getItem(key)) ? 'localStorage' : 'sessionStorage';\n    }\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = WebAuth;\n}\n\nif (typeof define === 'function' && define.amd) {\n    define('WebAuth', [], function() {\n        return WebAuth;\n    });\n}\n","function e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";export default o;export{n as InvalidTokenError};\n//# sourceMappingURL=jwt-decode.esm.js.map\n"],"sourceRoot":""}