{"version":3,"sources":["webpack://WebAuth/webpack/universalModuleDefinition","webpack://WebAuth/webpack/bootstrap","webpack://WebAuth/./index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","version","require","WebAuth","options","keys","accessToken","refreshToken","config","endpoints","hostname","url","method","authorizationType","headers","body","status","expired","ok","attempts","this","events","error","renewed","empty","load","storage","localStorage","getItem","_expirationAccessToken","_expirationRefreshToken","_stop","access","refresh","remember","constructor","getTokens","getExpirationToken","e","saveTokens","askServer","observer","renew","event","callback","removeItem","sessionStorage","isAccessTokenExpired","Date","getTime","setTimeout","isRefreshTokenExpired","response","tokenName","tokens","xHeaders","assign","Authorization","xBody","fullURL","payload","includes","toLowerCase","JSON","stringify","fetch","json","Error","clean","setItem","JWT","decoded","parse","atob","split","exp","Infinity"],"mappings":"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","file":"web-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebAuth\"] = factory();\n\telse\n\t\troot[\"WebAuth\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const { version } = require('./package.json');\n\nclass WebAuth {\n\n    constructor(options = {}) {\n        const {\n            keys = { accessToken: 'auth-key', refreshToken: 'auth-key-refresh' },\n            config = {\n                endpoints: {\n                    hostname: 'http://localhost:3000/',\n                    accessToken: {\n                        url: 'check-token',\n                        method: 'GET',\n                        authorizationType: 'Bearer',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: {},\n                        keys: {\n                            accessToken: 'accessToken',\n                            refreshToken: 'refreshToken',\n                        },\n                        status: {\n                            expired: 401,\n                            ok: 200,\n                        },\n                        attempts: 3\n                    },\n                    refreshToken: {\n                        url: 'refresh-token',\n                        method: 'POST',\n                        authorizationType: 'Bearer',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: {},\n                        keys: {\n                            accessToken: 'accessToken',\n                            refreshToken: 'refreshToken',\n                        },\n                        status: {\n                            expired: 401,\n                            ok: 201,\n                        },\n                        attempts: 3\n                    },\n                },\n            },\n        } = options;\n\n        this.keys = keys;\n        this.events = {\n            expired: () => {},\n            error: () => {},\n            renewed: () => {},\n            empty: () => {},\n            load: () => {},\n        };\n        this.config = config;\n        this.storage = (window.localStorage.getItem(this.keys.accessToken)) ? 'localStorage' : 'sessionStorage';\n\n        this._expirationAccessToken = null;\n        this._expirationRefreshToken = null;\n        this._stop = false;\n        this.version = version;\n    }\n\n    /**\n     * Set WebAuth and start observer\n     * @param access {String=} - accessToken\n     * @param refresh {String=} - refreshToken\n     * @param remember {Boolean=} - Save in session or local storage\n     * @returns {Promise<*|undefined>}\n     */\n    async set(access = '', refresh = '', remember) {\n        if (typeof remember === 'boolean') this.storage = remember ? 'localStorage' : 'sessionStorage';\n        const { accessToken = access, refreshToken = refresh } = this.constructor.getTokens(this.storage, this.keys);\n        if (!accessToken) return this.events.empty();\n        // Save expiration\n        try {\n            this._expirationAccessToken = this.constructor.getExpirationToken(accessToken);\n            if (refreshToken) this._expirationRefreshToken = this.constructor.getExpirationToken(refreshToken);\n        } catch (e) {\n            return this.events.error(e);\n        }\n        this.constructor.saveTokens(this.storage, this.keys, accessToken, refreshToken);\n\n        try {\n            await this.askServer();\n            this.events.load();\n            return this.observer();\n        } catch (e) {\n            if (e !== 'undefined') return this.events.error(e);\n            this.events.expired('accessToken');\n            return this.renew();\n        }\n    }\n\n    /**\n     * Set event\n     * @param event\n     * @param callback\n     */\n    on(event = '', callback = () => {}) {\n        this.events[event] = callback;\n    }\n\n    /**\n     * Clean tokens from storage\n     */\n    clean() {\n        // Remove from localStorage\n        window.localStorage.removeItem(this.keys.accessToken);\n        window.localStorage.removeItem(this.keys.refreshToken);\n        // Remove from sessionStorage\n        window.sessionStorage.removeItem(this.keys.accessToken);\n        window.sessionStorage.removeItem(this.keys.refreshToken);\n    }\n\n    /**\n     * Start expiration tokens observer\n     * @returns {Promise<*|undefined>|NodeJS.Timeout|*}\n     */\n    observer(attempts = 1) {\n        if (this._stop || !this._expirationAccessToken) return;\n        const isAccessTokenExpired = new Date().getTime() > this._expirationAccessToken;\n        if (!isAccessTokenExpired) return setTimeout(() => this.observer(), 1000);\n        if (attempts < 2) this.events.expired('accessToken');\n        if (!this._expirationRefreshToken) return;\n        // Try to get new refreshToken\n        return this.renew(attempts);\n    }\n\n    /**\n     * Force renew accessToken\n     * @returns {Promise<*|undefined|NodeJS.Timeout>}\n     */\n    async renew(attempts = 1) {\n        // Check refreshToken was not expired\n        const isRefreshTokenExpired = new Date().getTime() > this._expirationRefreshToken;\n        if (isRefreshTokenExpired) return this.events.expired('refreshToken');\n\n        const { refreshToken: config } = this.config.endpoints;\n        const { refreshToken } = this.constructor.getTokens(this.storage, this.keys);\n        try {\n            const { accessToken } = config.keys;\n            const response = await this.askServer('refreshToken');\n            this.constructor.saveTokens(this.storage, this.keys, response[accessToken], refreshToken);\n            this._expirationAccessToken = this.constructor.getExpirationToken(response[accessToken]);\n            this._expirationRefreshToken = this.constructor.getExpirationToken(refreshToken);\n            this.events.renewed();\n            return this.observer();\n        } catch (e) {\n            if (!e) return; // Only if was expired\n            if (attempts >= config.attempts) return this.events.error(e);\n            setTimeout(() => this.observer(attempts + 1), 1000 * (attempts + 1));\n        }\n    }\n\n    /**\n     * Send to server request to check or renew access token\n     * @param tokenName {String} - Could be accessToken or refreshToken\n     * @returns {Promise<any>}\n     */\n    async askServer(tokenName = 'accessToken') {\n        if (this._stop) return;\n        const {url, body, headers, method, authorizationType, keys, status} = this.config.endpoints[tokenName];\n        // Create payload\n        const tokens = this.constructor.getTokens(this.storage, this.keys);\n        const xHeaders = Object.assign(headers, {Authorization: `${authorizationType} ${tokens[tokenName]}`});\n        const xBody = Object.assign(body, { [keys[tokenName]]: tokens[tokenName] });\n        // Send request\n        const fullURL = `${this.config.endpoints.hostname}${url}`;\n        const payload = { method, headers: xHeaders };\n        if (['post', 'patch', 'put'].includes(method.toLowerCase())) payload.body = JSON.stringify(xBody);\n        const response = await fetch(fullURL, payload);\n        if (response.status === status.ok) return response.json();\n        if (response.status !== status.expired && response instanceof Error) throw response;\n        // Clean store and fire expired event\n        this.clean();\n        throw this.events.expired(tokenName);\n    }\n\n    /**\n     * Stop observer and clean tokens\n     * @param value\n     */\n    stop(value = true) {\n        this._stop = value;\n        this.clean();\n    }\n\n    /**\n     * Get tokens from storage\n     * @param storage {String} - Session or local storage\n     * @param keys {Object} - Key names of storage\n     * @returns {{accessToken: *, refreshToken: *}}\n     */\n    static getTokens(storage = 'sessionStorage', keys = {}) {\n        const accessToken = window[storage].getItem(keys.accessToken);\n        const refreshToken = window[storage].getItem(keys.refreshToken);\n        return (accessToken || refreshToken) ? { accessToken, refreshToken } : {};\n    }\n\n    /**\n     * Save tokens in storage\n     * @param storage {String} - Name of storage\n     * @param keys {Object} - Key names of storage\n     * @param accessToken {String} - JWT access\n     * @param refreshToken {String} - JWT refresh\n     */\n    static saveTokens(storage = 'sessionStorage', keys = {}, accessToken = '', refreshToken = '') {\n        window[storage].setItem(keys.accessToken, accessToken);\n        window[storage].setItem(keys.refreshToken, refreshToken);\n    }\n\n    /**\n     * Get expiration of JWT\n     * @param JWT {String} - Valid JWT\n     * @returns {number|number}\n     */\n    static getExpirationToken(JWT = '') {\n        const decoded = JSON.parse(atob(JWT.split('.')[1]));\n        if (typeof decoded !== 'object') throw new Error('Invalid JWT, please check.');\n        return ('exp' in decoded) ? decoded.exp * 1000 : Infinity;\n    }\n\n    /**\n     * Get the name of storage based on tokens existence\n     * @param key\n     * @returns {string} - Key name want search in storage\n     */\n    static getStorage(key = '') {\n        return (window.localStorage.getItem(key)) ? 'localStorage' : 'sessionStorage';\n    }\n}\n\nif (typeof define === 'function' && define.amd) {\n    define('WebAuth', [], function() {\n        return WebAuth;\n    });\n}\n\nif (typeof module !== 'undefined') {\n    module.exports = WebAuth;\n}\n"],"sourceRoot":""}